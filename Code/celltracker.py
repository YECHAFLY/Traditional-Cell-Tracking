'''
This file is the main file that follows the paper "Multiple Nuclei 
Tracking Using Integer Programming for Quantitative Cancer Cell C-
ycle Analysis". The proposed algorithm mainly contains two parts: 
Nuclei Segmentation and Nuclei Tracking. 

Nuclei Segmentation:
It includes three steps:
1. Binarization - using adaptive thresholding - adaptivethresh.py
2. Nuclei center detection - using gradient vector feild (GVF) - gvf.py
3. Nuclei boundary delinating - using watershed algorithm - watershed.py

Nuclei Tracking:
It includes three steps:
1. Neighboring Graph Constrction
2. Optimal MatchingRAY
3. Cell Division, Death, Segmentation Errors Detection& Processing

'''
import cv2
import sys
import os
import numpy as np
import imageio
from adaptivethresh import ADPTIVETHRESH as athresh
from gvf import GVF
from matplotlib import pyplot as plt
from watershed import WATERSHED as WS
from graph_construction import GRAPH
from matching import FEAVECTOR as FEA
from matching import SIMPLE_MATCH as MAT
from PIL import Image
from pyefd import elliptic_fourier_descriptors
import copy as cp

def set_date(vectors):
	'''
	This function is to add the start and end frame of each vector and
	combine the vector with same id.

	Input: the list of vectors in different frames.

	Output: the list of vectors of all cell with different id.

	'''
	max_id = 0
	for vector in vectors:
		for pv in vector:
			if pv.id > max_id:
				max_id = pv.id

	max_id = int(max_id)
	output = np.zeros((max_id, 4))
	output[:,0] = np.linspace(1, max_id, max_id) # set the cell ID
	output[:,1] = len(vectors)
	for frame, vector in enumerate(vectors):
		for pv in vector:
			if output[int(pv.id)-1][1] > frame:     # set the start frame
				output[int(pv.id)-1][1] = frame
			if output[int(pv.id)-1][2] < frame:     # set the end frame
				output[int(pv.id)-1][2] = frame
			output[int(pv.id)-1][3] = int(pv.l)          # set tht cell parent ID

	return output

def write_info(vector, name):
	'''
	This function is to write info. of each vector.

	Input: the list of vector generated by set_date() and
	       the name of output file.

	'''
	with open(name+".txt", "w+") as file:
		for p in vector:
			file.write(str(int(p[0]))+" "+\
				       str(int(p[1]))+" "+\
				       str(int(p[2]))+" "+\
				       str(int(p[3]))+"\n")

def normalize(image):
    '''
    This function is to normalize the input grayscale image by
    substracting globle mean and dividing standard diviation for
    visualization. 

    Input:  a grayscale image

    Output: normolized grascale image

    '''
    img = image.copy().astype(np.float32)
    img -= np.mean(img)
    img /= np.linalg.norm(img)
    # img = (img - img.min() )
    img = np.clip(img, 0, 255)
    img *= (1./float(img.max()))
    return (img*255).astype(np.uint8)

# read image sequence
# The training set locates at "resource/training/01" and "resource/training/02"
# The ground truth of training set locates at "resource/training/GT_01" and 
# "resource/training/GT_02"
# The testing set locates at "resource/testing/01" and "resource/testing/02"


path=os.path.join("/home/huoy1/Projects/celltracking/Fluo-N2DL-HeLa/01")
temporary_result = os.path.join("/home/huoy1/Projects/celltracking/temporary_result_Hela")

for r,d,f in os.walk(path):
    images = []
    enhance_images = []
    f.sort()
    for files in f:
        if files[-3:].lower()=='tif':
            temp = cv2.imread(os.path.join(r,files))
            gray = cv2.cvtColor(temp, cv2.COLOR_BGR2GRAY) 
            images.append(gray.copy())
            enhance_images.append(normalize(gray.copy()))

print "Total number of image is ", len(images)
print "The shape of image is ", images[0].shape, type(images[0][0,0])

def write_image(image, title, index, imgformat='.tiff'):
    if index < 10:
            name = '0'+str(index)
    else:
        name = str(index)
    cv2.imwrite(title+name+imgformat, image)

def load_image(title, index, imgformat='.tiff'):
    if index < 10:
            name = '0'+str(index)
    else:
        name = str(index)
    img_file = title+name+imgformat
    if os.path.exists(img_file):
        img = cv2.imread(title+name+imgformat)
        return img
    else:
        return []

def ws_simple(enhance_images):
    mark = []
    outbinary = []
    for ei in range(len(enhance_images)):
        img = np.zeros((enhance_images[ei].shape[0], enhance_images[ei].shape[1], 3), np.uint8)
        for c in range(3):
            img[:, :, c] = 255 - enhance_images[ei]
        gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
        # ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        ret, thresh = cv2.threshold(gray, 250, 255, cv2.THRESH_BINARY_INV)

        # noise removal
        kernel = np.ones((3, 3), np.uint8)
        opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)

        # sure background area
        sure_bg = cv2.dilate(opening, kernel, iterations=3)

        # Finding sure foreground area
        dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
        ret, sure_fg = cv2.threshold(dist_transform, 0.2 * dist_transform.max(), 255, 0)

        # Finding unknown region
        sure_fg = np.uint8(sure_fg)
        unknown = cv2.subtract(sure_bg, sure_fg)

        # Marker labelling
        ret, markers = cv2.connectedComponents(sure_fg)

        # # Add one to all labels so that sure background is not 0, but 1
        # markers = markers + 1

        # Now, mark the region of unknown with zero
        markers[unknown == 255] = 0

        markers = cv2.watershed(img, markers)
        u, counts = np.unique(markers, return_counts=True)
        counter = dict(zip(u, counts))
        valid_i = 1
        markers_unique = np.zeros(markers.shape)
        for i in counter:
            if counter[i] > 1200:
                markers_unique[markers == i] = 0
            else:
                markers_unique[markers == i] = valid_i
                valid_i = valid_i+1

        mark.append(markers_unique.astype(np.uint8))

        binary = markers_unique.copy()
        # binary[markers <= 1] = 0
        binary[markers_unique > 0] = 255
        outbinary.append(binary.astype(np.uint8))

    return outbinary, mark

def list2pts(ptslist):
    list_y = np.array([ptslist[0]])
    list_x = np.array([ptslist[1]])
    return np.append(list_y, list_x).reshape(2, len(list_y[0])).T

def unique_rows(a):
    a = np.ascontiguousarray(a)
    unique_a = np.unique(a.view([('', a.dtype)] * a.shape[1]))
    return unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))


centroid = None
slope_length = None



# Write image from different input
def write_mask16(images, name, index=-1):
    """
    Write image as 16 bits image
    """
    if index == -1:
        for i, img in enumerate(images):
            if i < 10:
                cv2.imwrite(name+"00"+str(i)+".tif", img.astype(np.uint16))
            elif i >= 10 and i < 100:
                cv2.imwrite(name+"0"+str(i)+".tif", img.astype(np.uint16))
            else:
                cv2.imwrite(name+str(i)+".tif", img.astype(np.uint16))
    else:
        if index < 10:
            cv2.imwrite(name+"00"+str(index)+".tif", images.astype(np.uint16))
        elif index >= 10 and index < 100:
            cv2.imwrite(name+"0"+str(index)+".tif", images.astype(np.uint16))
        else:
            cv2.imwrite(name+str(index)+".tif", images.astype(np.uint16))

def write_mask8(images, name, index=-1):
    """
    Write image as 8 bits image
    """
    if index == -1:
        for i, img in enumerate(images):
            if i < 10:
                cv2.imwrite(name+"00"+str(i)+".tif", img.astype(np.uint8))
            elif i >= 10 and i < 100:
                cv2.imwrite(name+"0"+str(i)+".tif", img.astype(np.uint8))
            else:
                cv2.imwrite(name+str(i)+".tif", img.astype(np.uint8))
    else:
        if index < 10:
            cv2.imwrite(name+"000"+str(index)+".tif", images.astype(np.uint8))
        elif index >= 10 and index < 100:
            cv2.imwrite(name+"00"+str(index)+".tif", images.astype(np.uint8))
        elif index >= 100 and index < 1000:
            cv2.imwrite(name+"0"+str(index)+".tif", images.astype(np.uint8))
        elif index >= 1000 and index < 10000:
            cv2.imwrite(name+str(index)+".tif", images.astype(np.uint8))
        else:
            raise

def write_pair8(images, name, index=-1):
    """
    Write image as 8 bits image with dilation
    """
    for i, img in enumerate(images):
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))
        img = cv2.dilate((img*255).astype(np.uint8),kernel,iterations = 3)
        if i < 10:
            cv2.imwrite(name+"00"+str(i)+".tif", img)
        elif i >= 10 and i < 100:
            cv2.imwrite(name+"0"+str(i)+".tif", img)
        else:
            cv2.imwrite(name+str(i)+".tif", img)

class GRAPH():
    '''
    This class contains all the functions needed to compute
    Delaunary Triangulation.

    '''

    def __init__(self, mark, binary, index):
        '''
        Input: the grayscale mark image with different label on each segments
               the binary image of the mark image
               the index of the image

        '''
        self.mark = mark[index]
        self.binary = binary[index]

    def rect_contains(self, rect, point):
        '''
        Check if a point is inside the image

        Input: the size of the image
               the point that want to test

        Output: if the point is inside the image

        '''
        if point[0] < rect[0]:
            return False
        elif point[1] < rect[1]:
            return False
        elif point[0] > rect[2]:
            return False
        elif point[1] > rect[3]:
            return False
        return True

    def draw_point(self, img, p, color):
        '''
        Draw a point

        '''
        cv2.circle(img, (p[1], p[0]), 2, color, cv2.FILLED, 16, 0)

    def draw_delaunay(self, img, subdiv, delaunay_color):
        '''
        Draw delaunay triangles and store these lines

        Input: the image want to draw
               the set of points: format as cv2.Subdiv2D
               the color want to use

        Output: the slope and length of each line ()

        '''
        triangleList = subdiv.getTriangleList();
        size = img.shape
        r = (0, 0, size[0], size[1])

        slope_length = [[]]
        for i in range(self.mark.max() - 1):
            slope_length.append([])

        for t_i, t in enumerate(triangleList):

            pt1 = (int(t[0]), int(t[1]))
            pt2 = (int(t[2]), int(t[3]))
            pt3 = (int(t[4]), int(t[5]))

            if self.rect_contains(r, pt1) and self.rect_contains(r, pt2) and self.rect_contains(r, pt3):

                # draw lines
                cv2.line(img, (pt1[1], pt1[0]), (pt2[1], pt2[0]), delaunay_color, 1, 16, 0)
                cv2.line(img, (pt2[1], pt2[0]), (pt3[1], pt3[0]), delaunay_color, 1, 16, 0)
                cv2.line(img, (pt3[1], pt3[0]), (pt1[1], pt1[0]), delaunay_color, 1, 16, 0)

                # store the length of line segments and their slopes
                for p0 in [pt1, pt2, pt3]:
                    for p1 in [pt1, pt2, pt3]:
                        if p0 != p1:
                            temp = self.length_slope(p0, p1)
                            if temp not in slope_length[self.mark[p0] - 1]:
                                slope_length[self.mark[p0] - 1].append(temp)

        return slope_length

    def length_slope(self, p0, p1):
        '''
        This function is to compute the length and theta for the given two points.

        Input: two points with the format (y, x)

        '''
        if p1[1] - p0[1]:
            slope = (p1[0] - p0[0]) / (p1[1] - p0[1])
        else:
            slope = 1e10

        length = np.sqrt((p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2)

        return length, slope

    def generate_points(self):
        '''
        Find the centroid of each segmentation

        '''
        centroids = []
        label = []
        max_label = self.mark.max()

        for i in range(1, max_label + 1):
            img = self.mark.copy()
            img[img != i] = 0
            if img.sum():
                _, contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_TC89_KCOS)
                m = cv2.moments(contours[0])

                if m['m00']:
                    label.append(i)
                    centroids.append((int(round(m['m01'] / m['m00'])), \
                                      int(round(m['m10'] / m['m00']))))
                else:
                    label.append(i)
                    centroids.append((0, 0))

        return centroids, label

    def run(self, animate=False):
        '''
        The pipline of graph construction.

        Input: if showing a animation (False for default)

        Output: centroids: # of segments * 2   (y, x)
                slopes and length: # of segments * # of slope_length

        '''
        # Read in the image.
        img_orig = self.binary.copy()

        # Rectangle to be used with Subdiv2D
        size = img_orig.shape
        rect = (0, 0, size[0], size[1])

        # Create an instance of Subdiv2D
        subdiv = cv2.Subdiv2D(rect);

        # find the centroid of each segments
        points, label = self.generate_points()

        # add and sort the centroid to a numpy array for post processing
        centroid = np.zeros((self.mark.max(), 2))
        for p, l in zip(points, label):
            centroid[l - 1] = p

        outimg = []
        # Insert points into subdiv
        for idx_p, p in enumerate(points):
            subdiv.insert(p)

            # Show animation
            if animate:
                img_copy = img_orig.copy()
                # Draw delaunay triangles
                self.draw_delaunay(img_copy, subdiv, (255, 255, 255));
                outimg.append(img_copy)
                display_image(img_copy)
                img_copy = cv2.resize(img_copy, (314, 200))
                cv2.imwrite("delaunay_" + str(idx_p).zfill(3) + ".png", img_copy)
                clear_output(wait=True)

        # Draw delaunay triangles
        slope_length = self.draw_delaunay(img_orig, subdiv, (255, 255, 255));

        # Draw points
        for p in points:
            self.draw_point(img_orig, p, (0, 0, 255))

        # show images
        if animate:
            display_image(img_orig)

        print "length of centroid: ", len(centroid)
        return centroid, slope_length




Max_dis = 100000

def write_image(image, title, index, imgformat='.tif'):
    if index < 10:
            name = '00'+str(index)
    else:
        name = '0'+str(index)
    cv2.imwrite(title+name+imgformat, image.astype(np.uint16))

class FEAVECTOR():
    '''
    This class builds a feature vector for each segments.
    The format of each vector is:
                    v(k,i) = [c(k,i), s(k, i), h(k, i), e(k, i)], where k is the
                    index of the image (frame) and i is the label of each segment.

                    c(k,i): the centroid of each segment (y, x);
                    s(k,i): the binary shape of each segment;
                    h(k,i): the intensity distribution (hsitogram) of the segment;
                    e(k,i): the spatial distribution of the segment. Its format is
                    like (l(k, i, p), theta(k, i, p)), where p represent different
                    line connected with different segment.

    '''
    def __init__(self, centroid=None, shape=None, histogram=None, spatial=None, \
                       ID=None, start = None, end=None, label=None, ratio=None, area=None, cooc=None):
        self.c = centroid
        self.s = shape
        self.h = histogram
        self.e = spatial
        self.id = ID
        self.start = start
        self.end = end
        self.l = label
        self.a = area
        self.r = ratio
        self.cm = cooc

    def add_id(self, num, index):
        '''
        This function adds cell id for each cell.

        '''
        if index == 0:
            self.id = np.linspace(1, num, num)
        else:
            self.id= np.linspace(-1, -1, num)

    def add_label(self):
        '''
        This function is to add labels for each neclei for post process.

        '''
        self.l = np.linspace(0, 0, len(self.c))

    def set_centroid(self, centroid):
        '''
        This function sets the centroid for all neclei.

        Input: the set of centroid: # of images * # of neclei * 2 (y, x)

        Output: None

        '''
        self.c = centroid

    def set_spatial(self, spatial):
        '''
        This function sets the spatial distrbution for all neclei.

        Input: the set of centroid: # of images * # of neclei * # of line segments (length, slope)

        Output: None

        '''
        self.e = spatial

    def set_shape(self, image, marker):
        '''
        This function sets the binary shape for all necluei.

        Input: the original images: # of images * height * weight
               the labeled images: # of images * nucei's height * nucei's weight ()

        Output: None

        '''
        def boundingbox(image):
            y, x = np.where(image)
            return min(x), min(y), max(x), max(y)

        shape = []

        for label in range(1, marker.max()+1):
            tempimg = marker.copy()
            tempimg[tempimg!=label] = 0
            tempimg[tempimg==label] = 1
            if tempimg.sum():
                minx, miny, maxx, maxy = boundingbox(tempimg)
                shape.append((tempimg[miny:maxy+1, minx:maxx+1], image[miny:maxy+1, minx:maxx+1]))
            else:
                shape.append(([], []))

        self.s = shape

    def set_histogram(self):
        '''
        Note: this function must be implemneted after set_shape().

        '''
        def computehistogram(image):
            h, w = image.shape[:2]
            his = np.zeros((256,1))
            for y in range(h):
                for x in range(w):
                    his[image[y, x], 0] += 1
            return his

        assert self.s != None, "this function must be implemneted after set_shape()."

        his = []

        for j in range(len(self.s)):
            img = self.s[j][1]
            if len(img):
                temphis = computehistogram(img)
                his.append(temphis)
            else:
                his.append(np.zeros((256,1)))

        self.h = his

    def add_efd(self):
        coeffs = []
        for i in range(len(self.s)):
            try:
                _, contours, hierarchy = cv2.findContours(self.s[i][0].astype(np.uint8), 1, 2)
                if not len(contours):
                    coeffs.append(0)
                    continue
                cnt = contours[0]
                if len(cnt) >= 5:
                    contour = []
                    for i in range(len(contours[0])):
                        contour.append(contours[0][i][0])
                    coeffs.append(elliptic_fourier_descriptors(contour, order=10, normalize=False))
                else:
                    coeffs.append(0)
            except AttributeError:
                coeffs.append(0)
        self.r = coeffs

    def add_co_occurrence(self, level=10):
        '''
        This funciton is to generate co-occurrence matrix for each cell. The structure of
        output coefficients is:
        [Entropy, Energy, Contrast, Homogeneity]
        '''
        # generate P metrix.
        self.cm = []
        for j in range(len(self.s)):
            if not len(self.s[j][1]):
                p_0 = np.zeros((level,level))
                p_45 = np.zeros((level,level))
                p_90 = np.zeros((level,level))
                p_135 = np.zeros((level,level))
                self.cm.append([np.array([0, 0, 0, 0]),[p_0, p_45, p_90, p_135]])
                continue
            max_p, min_p = np.max(self.s[j][1]), np.min(self.s[j][1])
            range_p = max_p - min_p
            img = np.round((np.asarray(self.s[j][1]).astype(np.float32)-min_p)/range_p*level)
            h, w = img.shape[:2]
            p_0 = np.zeros((level,level))
            p_45 = np.zeros((level,level))
            p_90 = np.zeros((level,level))
            p_135 = np.zeros((level,level))
            for y in range(h):
                for x in range(w):
                    try:
                        p_0[img[y,x],img[y,x+1]] += 1
                    except IndexError:
                        pass
                    try:
                        p_0[img[y,x],img[y,x-1]] += 1
                    except IndexError:
                        pass
                    try:
                        p_90[img[y,x],img[y+1,x]] += 1
                    except IndexError:
                        pass
                    try:
                        p_90[img[y,x],img[y-1,x]] += 1
                    except IndexError:
                        pass
                    try:
                        p_45[img[y,x],img[y+1,x+1]] += 1
                    except IndexError:
                        pass
                    try:
                        p_45[img[y,x],img[y-1,x-1]] += 1
                    except IndexError:
                        pass
                    try:
                        p_135[img[y,x],img[y+1,x-1]] += 1
                    except IndexError:
                        pass
                    try:
                        p_135[img[y,x],img[y-1,x+1]] += 1
                    except IndexError:
                        pass
            Entropy, Energy, Contrast, Homogeneity = 0, 0, 0, 0
            for y in range(10):
                for x in range(10):
                    if 0 not in [p_0[y,x], p_45[y,x], p_90[y,x], p_135[y,x]]:
                        Entropy -= (p_0[y,x]*np.log2(p_0[y,x])+\
                                    p_45[y,x]*np.log2(p_45[y,x])+\
                                    p_90[y,x]*np.log2(p_90[y,x])+\
                                    p_135[y,x]*np.log2(p_135[y,x]))/4
                    else:
                        temp = 0
                        for p in [p_0[y,x], p_45[y,x], p_90[y,x], p_135[y,x]]:
                            if p != 0:
                                temp += p*np.log2(p)
                        Entropy -= temp/4
                    Energy += (p_0[y,x]**2+\
                                p_45[y,x]**2+\
                                p_90[y,x]**2+\
                                p_135[y,x]**2)/4
                    Contrast += (x-y)**2*(p_0[y,x]+\
                                        p_45[y,x]+\
                                        p_90[y,x]+\
                                        p_135[y,x])/4
                    Homogeneity += (p_0[y,x]+\
                                    p_45[y,x]+\
                                    p_90[y,x]+\
                                    p_135[y,x])/(4*(1+abs(x-y)))
            self.cm.append([np.array([Entropy, Energy, Contrast, Homogeneity]),[p_0, p_45, p_90, p_135]])

    def add_area(self):
        area = []
        for i in range(len(self.s)):
            area.append(np.count_nonzero(self.s[i][0]))
        self.a = area

    def generate_vector(self):
        '''
        This function is to convert the vector maxtrics into a list.

        Output: a list of vector: [v0, v1, ....]

        '''
        vector = []
        for i in range(len(self.c)):
                vector.append(FEAVECTOR(centroid=self.c[i],shape=self.s[i],\
                                        histogram=self.h[i],spatial=self.e[i],\
                                        ID=self.id[i],label=self.l[i],\
                                        ratio=self.r[i],area=self.a[i], cooc=self.cm[i]))
        return vector

class SIMPLE_MATCH():
    '''
    This class is simple matching a nucleus into a nucleus in the previous frame by
    find the nearest neighborhood.

    '''
    def __init__(self, index0, index1, images, vectors):
        self.v0 = cp.copy(vectors[index0])
        self.v1 = cp.copy(vectors[index1])
        self.i0 = index0
        self.i1 = index1
        self.images = images
        self.vs = cp.copy(vectors)

    def distance_measure(self, pv0, pv1, alpha1=0.5, alpha2=0.25, alpha3=0.25, phase = 1):
        '''
        This function measures the distence of the two given feature vectors.

        This distance metrics we use is:
                        d(v(k, i), v(k+1, j)) = alpha1 * d(c(k, i), c(k+1, j)) +
                                                alpha2 * q1 * d(s(k, i), s(k+1, j)) +
                                                alpha3 * q2 * d(h(k, i), h(k+1, j)) +
                                                alpha4 * d(e(k, i), e(k+1, j))
        Input: The two given feature vectors,
               and the set of parameters.

        Output: the distance of the two given vectors.

        '''
        def centriod_distance(c0, c1, D=30.):
            dist = np.sqrt((c0[0]-c1[0])**2 + (c0[1]-c1[1])**2)
            return dist/D if dist < D else 1

        def efd_distance(r0, r1, order=8):
            def find_max(max_value, test):
                if max_value < test:
                    return test
                return max_value
            dis = 0
            if type(r0) is not int and type(r1) is not int:
                max_a, max_b, max_c, max_d = 0, 0, 0, 0
                for o in range(order):
                    dis += ((r0[o][0]-r1[o][0])**2+\
                            (r0[o][1]-r1[o][1])**2+\
                            (r0[o][2]-r1[o][2])**2+\
                            (r0[o][3]-r1[o][3])**2)
                    max_a = find_max(max_a, (r0[o][0]-r1[o][0])**2)
                    max_b = find_max(max_b, (r0[o][1]-r1[o][1])**2)
                    max_c = find_max(max_c, (r0[o][2]-r1[o][2])**2)
                    max_d = find_max(max_d, (r0[o][3]-r1[o][3])**2)
                dis /= (order*(max_a+max_b+max_c+max_d))
                if dis > 1.1:
                    print dis, max_a, max_b, max_c, max_d
                    raise
            else:
                dis = 1
            return dis

        def cm_distance(cm0, cm1):
            return ((cm0[0]-cm1[0])**2+\
                   (cm0[1]-cm1[1])**2+\
                   (cm0[2]-cm1[2])**2+\
                   (cm0[3]-cm1[3])**2)/\
                   (max(cm0[0],cm1[0])**2+\
                    max(cm0[1],cm1[1])**2+\
                    max(cm0[2],cm1[2])**2+\
                    max(cm0[3],cm1[3])**2)

        if len(pv0.s[0]) and len(pv1.s[0]):
            dist = 	alpha1 * centriod_distance(pv0.c, pv1.c)+ \
                    alpha2 * efd_distance(pv0.r, pv1.r, order=8) * phase + \
                    alpha3 * cm_distance(pv0.cm[0], pv1.cm[0]) * phase
        else:
            dist = Max_dis

        return dist

    def phase_identify(self, pv1, min_times_MA2ma = 2, RNN=False):
        '''
        Phase identification returns 0 when mitosis appears, vice versa.

        '''
        if not RNN:
            _, contours, hierarchy = cv2.findContours(pv1.s[0].astype(np.uint8), 1, 2)
            if not len(contours):
                return 1
            cnt = contours[0]
            if len(cnt) >= 5:
                (x,y),(ma,MA),angle = cv2.fitEllipse(cnt)
                if ma and MA/ma > min_times_MA2ma:
                    return 0
                elif not ma and MA:
                    return 0
                else:
                    return 1
            else:
                return 1

        else:
            try:
                if model.predict([pv1.r.reshape(40)])[-1]:
                    return 0
                else:
                    return 1
            except AttributeError:
                return 1

    def find_match(self, max_distance=1,a_1=0.5,a_2=0.25,a_3=0.25, rnn=False):
        '''
        This function is to find the nearest neighborhood between two
        successive frame.

        '''
        def centriod_distance(c0, c1, D=30.):
            dist = np.sqrt((c0[0]-c1[0])**2 + (c0[1]-c1[1])**2)
            return dist/D if dist < D else 1

        for i, pv1 in enumerate(self.v1):
            dist = np.ones((len(self.v0), 3), np.float32)*max_distance
            count = 0
            q = self.phase_identify(pv1, 3, RNN=rnn)
            for j, pv0 in enumerate(self.v0):
                if centriod_distance(pv0.c, pv1.c) < 1 and pv0.a:
                    dist[count][0] = self.distance_measure(pv0, pv1, alpha1=a_1, alpha2=a_2, alpha3=a_3, phase=q)
                    dist[count][1] = pv0.l
                    dist[count][2] = pv0.id
                    count += 1

            sort_dist = sorted(dist, key=lambda a_entry: a_entry[0])
            print "dis: ", sort_dist[0][0]
            if sort_dist[0][0] < max_distance:
                self.v1[i].l = sort_dist[0][1]
                self.v1[i].id = sort_dist[0][2]

    def mitosis_refine(self, rnn=False):
        '''
        This function is to find died cell due to the by mitosis.

        '''
        def find_sibling(pv0):
            '''
            This function is to find sibling cells according to the centroid of
            pv0. The criteria of sibling is:
                    1. the jaccard cooeficient of the two cells is above 0.5
                    2. the sum of the two areas should in the range [A, 2.5A], where
                       A is the area of the pv0
                    3. the position of the two cells should be not larger than 20 pixels.

            Input: pv0: the parent cell that you want to find siblings;

            Output: the index of the siblings.

            '''
            def maxsize_image(image1, image2):
                y1, x1 = np.where(image1)
                y2, x2 = np.where(image2)
                return min(min(x1), min(x2)), min(min(y1), min(y2)), \
                       max(max(x1), max(x2)), max(max(y1), max(y2)),

            def symmetry(image, shape):
                h, w = image.shape[:2]
                newimg = np.zeros(shape)
                newimg[:h, :w] = image
                v = float(shape[0] - h)/2.
                u = float(shape[1] - w)/2.
                M = np.float32([[1,0,u],[0,1,v]])
                return cv2.warpAffine(newimg,M,(shape[1],shape[0]))

            def jaccard(s0, s1):
                minx, miny, maxx, maxy = maxsize_image(s0, s1)
                height = maxy - miny + 1
                width = maxx - minx + 1

                img0 = symmetry(s0, (height, width))
                img1 = symmetry(s1, (height, width))

                num = 0.
                deno = 0.
                for y in range(height):
                    for x in range(width):
                        if img0[y, x] and img1[y, x]:
                            num += 1
                        if img0[y, x] or img1[y, x]:
                            deno += 1

                return num/deno

            sibling_cand = []
            for i, pv1 in enumerate(self.v1):
                if np.linalg.norm(pv1.c-pv0.c) < 50:
                    sibling_cand.append([pv1, i])

            sibling_pair = []
            area = pv0.s[0].sum()
            jaccard_value = []
            for sibling0 in sibling_cand:
                for sibling1 in sibling_cand:
                    if (sibling1[0].c != sibling0[0].c).all():
                        sum_area = sibling1[0].s[0].sum()+sibling0[0].s[0].sum()
                        similarity = jaccard(sibling0[0].s[0], sibling1[0].s[0])
                        if similarity > 0.4 and (sum_area > 2*area):
                            sibling_pair.append([sibling0, sibling1])
                            jaccard_value.append(similarity)
            if len(jaccard_value):
                return sibling_pair[np.argmax(jaccard_value)]
            else:
                return 0

        v1_ids = []
        for pv1 in self.v1:
            v1_ids.append(pv1.id)

        for i, pv0 in enumerate(self.v0):
            if pv0.id not in v1_ids and len(pv0.s[0]) and self.phase_identify(pv0, 3, RNN=rnn):
                sibling = find_sibling(pv0)
                if sibling:
                    [s0, s1] = sibling
                    if s0[0].l==0 and s1[0].l==0 and \
                       s0[0].id==-1 and s1[0].id==-1:
                        self.v1[s0[1]].l = pv0.id
                        self.v1[s1[1]].l = pv0.id

        return self.v1

    def match_missing(self, mask, max_frame = 1, max_distance = 10, min_shape_similarity = 0.6):
        '''
        This function is to match the cells that didn't show in the last frame caused by
        program fault. In order to match them, we need to seach the cell in the previous
        frame with in the certain range and with similar shape.

        '''
        def centriod_distance(c0, c1):
            dist = np.sqrt((c0[0]-c1[0])**2 + (c0[1]-c1[1])**2)
            return dist

        def maxsize_image(image1, image2):
            y1, x1 = np.where(image1)
            y2, x2 = np.where(image2)
            return min(min(x1), min(x2)), min(min(y1), min(y2)), \
                   max(max(x1), max(x2)), max(max(y1), max(y2)),

        def symmetry(image, shape):
            h, w = image.shape[:2]
            newimg = np.zeros(shape)
            newimg[:h, :w] = image
            v = float(shape[0] - h)/2.
            u = float(shape[1] - w)/2.
            M = np.float32([[1,0,u],[0,1,v]])
            return cv2.warpAffine(newimg,M,(shape[1],shape[0]))

        def shape_similarity(s0, s1):
            if len(s0) and len(s1):
                minx, miny, maxx, maxy = maxsize_image(s0, s1)
                height = maxy - miny + 1
                width = maxx - minx + 1

                img0 = symmetry(s0, (height, width))
                img1 = symmetry(s1, (height, width))

                num = 0.
                deno = 0.
                for y in range(height):
                    for x in range(width):
                        if img0[y, x] and img1[y, x]:
                            num += 1
                        if img0[y, x] or img1[y, x]:
                            deno += 1
                return num/deno

            else:
                return 0.

        def add_marker(index_find, index_new, pv0_id):
            temp = mask[index_new]
            find = mask[index_find]
            temp[find==pv0_id] = pv0_id
            return temp

        for i, pv1 in enumerate(self.v1):
            if pv1.id == -1:
                for index in range(1, max_frame+1):
                    if self.i0-index >= 0:
                        vt = self.vs[self.i0-index]
                        for pv0 in vt:
                            if centriod_distance(pv0.c, pv1.c) < max_distance and \
                                shape_similarity(pv0.s[0], pv1.s[0]) > min_shape_similarity:
                                self.v1[i].id = pv0.id
                                self.v1[i].l = pv0.l
                                print "missing in frame: ", self.i1, "find in frame: ", \
                                       self.i0-index, "ID: ", pv0.id, " at: ", pv0.c
                                for i in range(self.i0-index+1, self.i1):
                                    mask[i] = add_marker(self.i0-index, i, pv0.id)
        return mask

    def new_id(self, vectors):
        '''
        This function is to add new labels for the necles that are marked as -1.


        '''
        def find_max_id(vectors):
            max_id = 0
            for vt in vectors:
                for pt in vt:
                    if pt.id > max_id:
                        max_id = pt.id
            return max_id
        max_id = find_max_id(self.vs)
        max_id += 1
        for i, pv1 in enumerate(self.v1):
            if pv1.id == -1:
                self.v1[i].id = max_id
                max_id += 1

    def generate_mask(self, marker, index, isfinal=False):
        '''
        This function is to generate a 16-bit image as mask image.

        '''
        h, w = marker.shape[:2]
        mask = np.zeros((h, w), np.uint16)
        pts = list(set(marker[marker>0]))
        if not isfinal:
            assert len(pts)==len(self.v0), 'len(pts): %s != len(self.v0): %s' % (len(pts), len(self.v0))
            for pt, pv in zip(pts, self.v0):
                mask[marker==pt] = pv.id

        else:
            assert len(pts)==len(self.v1), 'len(pts): %s != len(self.v0): %s' % (len(pts), len(self.v1))
            for pt, pv in zip(pts, self.v1):
                mask[marker==pt] = pv.id

        os.chdir(".")
        write_mask16(mask, "mask", index)
        os.chdir(os.pardir)
        return mask

    def return_vectors(self):
        '''
        This function is to return the vectors that we have already
        changed.

        Output: the vectors from the k+1 frame.

        '''
        return self.v1

def find_max_id(temp_vector):
    max_id = 0
    for pv in temp_vector:
        for p in pv:
            if p.id > max_id:
                max_id = p.id
    return max_id

def main():

    use_simple_marker = True

    # Binarization
    bmarks, marks = ws_simple(enhance_images)
    # path = "/home/huoy1/Projects/celltracking/Fluo-N2DL-HeLa/01_GT/SEG"
    # gts = []
    # for r, d, f in os.walk(path):
    #     for files in f:
    #         if files[-3:].lower() == 'tif':
    #             temp = cv2.imread(os.path.join(r, files), cv2.IMREAD_UNCHANGED)
    #             gts.append([temp, files[-6:-4]])
    # print "number of gts: ", len(gts)
    #
    # path = "PATH_TO_SEGMENTATION_RESULTS"
    # binarymarks = []
    # for r, d, f in os.walk(path):
    #     for files in f:
    #         if files[:4] == 'mark':
    #             temp = cv2.imread(os.path.join(r, files))
    #             gray = cv2.cvtColor(temp, cv2.COLOR_BGR2GRAY)
    #             binarymarks.append([gray, files[-6:-4]])
    # print "number of segmentation image: ", len(binarymarks)
    #
    # jaccards = []
    #
    # for gt in gts:
    #     for binarymark in binarymarks:
    #         if gt[1] == binarymark[1]:
    #             print "enter...", gt[1]
    #             list_pts = set(gt[0][gt[0] > 0])
    #             list_seg = set(binarymark[0][binarymark[0] > 0])
    #             for pt in list_pts:
    #                 for seg in list_seg:
    #                     pts_gt = np.where(gt[0] == pt)
    #                     pts_seg = np.where(binarymark[0] == seg)
    #                     pts_gt = list2pts(pts_gt)
    #
    #                     pts_seg = list2pts(pts_seg)
    #                     pts = np.append(pts_gt, pts_seg).reshape(len(pts_gt) + len(pts_seg), 2)
    #                     union_pts = unique_rows(pts)
    #
    #                     union = float(len(union_pts))
    #                     intersection = float(len(pts_seg) + len(pts_gt) - len(union_pts))
    #
    #                     if intersection / union > 0.5:
    #                         jaccards.append(intersection / union)
    # jaccard = float(sum(jaccards)) / float(len(jaccards))
    # print "jaccard: ", jaccard, "number of Nuclei: ", len(jaccards)

    # This part is the small test for graph_contruction.py.
    # Input:  grayscale marker image
    #         binary marker image
    # Output: a text file includes the centroid and the length and slope for each neighbor.


    centroid = []
    slope_length = []
    for i in range(len(images)):
        print "  graph_construction: image ", i
        print "max pixel: ", marks[i].max()
        graph = GRAPH(marks, bmarks, i)
        if i == 0:
            tempcentroid, tempslope_length = graph.run(False)
        else:
            tempcentroid, tempslope_length = graph.run()
        centroid.append(tempcentroid)
        slope_length.append(tempslope_length)
    print "finish!"

    # This part is to test the matching scheme with single image
    # Input: the original image;
    #        the labeled image;
    #        the binary labeled image.


    vector = []
    max_id = 0
    for i in range(len(images)):
        print "  feature vector: image ", i
        v = FEAVECTOR()
        v.set_centroid(centroid[i])
        v.set_spatial(slope_length[i])
        v.set_shape(enhance_images[i], marks[i])
        v.set_histogram()
        v.add_label()
        v.add_id(marks[i].max(), i)
        v.add_efd()
        v.add_area()
        v.add_co_occurrence()
        vector.append(v.generate_vector())
        print "num of nuclei: ", len(vector[i])

    print "finish"

    mask = []
    temp_vector = cp.deepcopy(vector)

    # Feature matching
    for i in range(len(images) - 1):
        print "  Feature matching: image ", i
        m = SIMPLE_MATCH(i, i + 1, [images[i], images[i + 1]], temp_vector)
        mask.append(m.generate_mask(marks[i], i))
        m.find_match(0.7, 0.7, 0.15, 0.15)
        temp_vector[i + 1] = m.mitosis_refine()
        m.new_id(temp_vector)
        temp_vector[i + 1] = m.return_vectors()

    print "  Feature matching: image ", i + 1
    mask.append(m.generate_mask(marks[i + 1], i + 1, True))
    os.chdir(temporary_result)
    cells = set_date(temp_vector)
    write_info(cells, "res_track")
    print "finish!"

    # This part is to mark the result in the normolized image and
    # write the gif image.
    max_id = find_max_id(temp_vector)
    max_id = int(max_id)
    colors = [np.random.randint(0, 255, size=max_id), \
              np.random.randint(0, 255, size=max_id), \
              np.random.randint(0, 255, size=max_id)]
    font = cv2.FONT_HERSHEY_SIMPLEX
    selecy_id = 9
    enhance_imgs = []
    for i, m in enumerate(mask):
        print "  write the gif image: image ", i
        enhance_imgs.append(cv2.cvtColor(enhance_images[i], cv2.COLOR_GRAY2RGB))
        for pv in temp_vector[i]:
            center = pv.c
            if not pv.l:
                color = (colors[0][int(pv.id) - 1], \
                         colors[1][int(pv.id) - 1], \
                         colors[2][int(pv.id) - 1],)
            else:
                color = (colors[0][int(pv.l) - 1], \
                         colors[1][int(pv.l) - 1], \
                         colors[2][int(pv.l) - 1],)

            if m[int(center[0]), int(center[1])]:
                enhance_imgs[i][m == pv.id] = color
                cv2.putText(enhance_imgs[i], \
                            str(int(pv.id)), (int(pv.c[1]), \
                                              int(pv.c[0])),
                            font, 0.5, \
                            (255, 255, 255), 1)
    os.chdir(temporary_result)
    imageio.mimsave('mitosis_final.gif', enhance_imgs, duration=0.6)
    print "finish!"



# if python says run, then we should run
if __name__ == '__main__':
    main()